CSEG segment
          assume cs:CSEG, ds:CSEG
          org 100h
Start:
;Переходим на метку инициализации. Нам нужно будет перехватить 
;прерывание 1сh, а также оставить программу резидентной в памяти
          jmp Init
 
;       ==== Обработчик 1ah-ого прерывания ====
;Ниже идет,собственно, обработчик 1ah прерывания (он будет резидентный)
;После того, как программа выйдет, процедура Int_1сh_proc останется в 
;памяти и будет контролировать прерывание 1сh.
 
Int_1ch_proc proc
         jmp ok_02
count dw 6
Ok_02:
          push      ds          ;Сохраним регистры
          push      dx
          push      ax
          push      bx
          push      cx
          push      cs          ;Адрес строки должен быть в DS:DX
          pop       ds
   
          dec   count;
          jnz jumpp
          mov al, 'Q'
          mov ah, 0eh
          mov bl, 0fh
          mov cx,  1
          int     10h
          mov count , 546
jumpp: 
          pop cx
          pop bx
          pop ax
          pop dx            ;Восстановим использованные регистры
          pop ds        ;иначе, задержка окончена
          ;jmp dword ptr cs:[Int_1ch_vect]
 
          iret          ;Продолжим работу (выйдем из прерывания)
;Программа, выводящая строку, считает, что на экран было выведено ее
;сообщение. Но на самом деле это не так!
 
;Переменная для хранения оригинального адреса обработчика 1сh 
Q db 'Q$'
sek     db      '  ','$';
 
Int_1ch_vect dd ?
 
;Строка, которая будет выводитс
Int_1ch_proc endp
;       ==== Конец обработчика 1сh-ого прерывания ====
 
;Со следующей метки нашей программы уже не будет в памяти
;(это нерезидентная часть). Она затрется сразу после выхода (после
;вызова прерывания 27h).
Init:
;Установим наш обработчик (Int_1сh_proc) (адрес нашего обработчика,
;если быть точнее) на 1ah прерывание. Это позволяет сделать функция
;25h прерывания 21h.
;Но прежде нам нужно запомнить оригинальный адрес этого прерывания.
;Для этого используется функция 35h прерывания 21h:
 
    mov ah,35h  ;AH содержит номер функции (это понятно)
    mov al,1ch  ;AL указывает номер прерывания, адрес (или вектор)
            ;которого нужно получить
    int 21h     ;Теперь в ES:BX адрес (вектор) 21h прерывания
            ;(ES - сегмент, BX - смещение)
 
    mov word ptr Int_1ch_vect,bx
    mov word ptr Int_1ch_vect+2,es  ;! Обратите внимание на форму 
                                                            ;записи
;Итак, адрес сохранили. Теперь перехватываем прерывание:
    mov ax,251ch
    mov dx,offset Int_1ch_proc  ;DX должен указывать на наш
                    ;обработчик (т.е. Int_1сh_proc)
    int 21h
 
;Все!Теперь, если какая-либо программа вызовет 1сh,то вначале компьютер
;попадет на наш обработчик (Int_1сh_proc).
;Что осталось? Завершить программу, оставив ее резидентной в памяти
;(чтобы никто не затер наш обработчик, иначе компьютер зависнет).
 
    mov dx,offset Init
    int 27h
;Прерывание 27h выходит в DOS (как 20h),при этом оставив нашу программу
;резидентной.DX должен указывать на последний байт, остающийся в памяти
;(это как раз метка Init). Т.е. в памяти остается от 0000h до адреса,
;по которому находится метка Init.
 
CSEG ends
end Start