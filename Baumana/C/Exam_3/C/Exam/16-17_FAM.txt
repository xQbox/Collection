Вопрос 16-17 (Структуры с полями указателями, flexible array member)

Теория:	
	1) Структуры с полями-указателями
		- В си определена операция присваивания (=) для структурных переменных.
		  С помощью операции присваивания. (выполняет побитовое копирование 
		  структурных переменных)
		  	- Поверхностное копирование ( shallow coping )
				- не копирует содержимое на которое 
				  ссылается структурная переменная.  	
			- Глубокое копирование

		1) Для динамически распределяемых переменных, также называемых 
		указателями, используется неглубокое копирование

		2) Для статически распределяемых переменных или массивов используется 
		глубокое копирование	
	
	2) Flexible array member 
		- Начиная со стандарта С99 появилась возможность создавать 
		  структуры переменного размера. Т.е.
		  			struct tree_t 
		  			{ 
		      				tree_t *left;
		      				tree_t *right;
		  				int arr[]; // обязательно последний!!
		  				(без указания размерa массива); 
		      			};
		  при применений функции sizeof(struct tree_t) размер указанного поля
		  будет равен  0 + 8 + 8 = 16. Такое значение вернет функция sizeof() 
		  так как на этапе компиляции размер int arr[] неизвестен. 
		  
		- Соседние ячейки памяти используются для хранения элементов структуры 
			в памяти.
		- В предыдущих стандартах языка программирования C мы могли объявлять 
		  элемент массива нулевого размера вместо гибкого элемента массива. 
		  Компилятор GCC со стандартом C89 рассматривает его как массив 
		  нулевого 
		  размера.	
		- ДОЛЖЕН БЫТЬ ПОСЛЕДНИМ ЧЛЕНОМ СТРУКТУРЫ.

Дополнительно:
	
	- Насколько я понимаю, в C нет встроенной поверхностной копии
	  (shallow copy) или глубокой копии (deep copy).
	  В C существует только один встроенный метод копирования при использовании 
	  оператора '=': копирование данных.
	  C хранит метаданные структуры в оперативной памяти и гарантирует, что после 
	  создания структуры ее размер не изменится, а к переменным можно будет 
	  получить 
	  доступ из определенных частей выделенной памяти.
	  Когда вы используете оператор "=", он только копирует данные, хранящиеся в 
	  структуре, но побитно в другую структуру, поскольку они имеют одинаковый 
	  размер.
	  Статически выделенные переменные и массивы в структуре имеют фиксированный 
	  размер и полностью хранятся в выделенной памяти структуры.
	  Все динамически выделяемые переменные являются указателями. Переменные 
	  указателей(void *, int *, char * и др) — это статически выделенная память, 
	  эквивалентная беззнаковому длинному целому числу( unsigned long int ).
	  Когда у вас есть указатель в структуре, он хранит только адрес, память, на
	  которую он указывает, иначе говоря, динамически выделяемое местоположение, 
	  структура на самом деле не содержит никакой информации о том, что указатель 
	  указывает на память. Именно операционная система и компилятор отслеживают
	  динамически выделяемую память.

Практика: 

	1) Пример глубокого и поверхностного копирования	
		#include <stdio.h>
		#include<stdlib.h> 
		struct Foo
		{
		    int value_1;
		    int *value_2;
		    int value_3[3];
		}S1,S2;

		 
		void print(struct Foo S)
		{
		    printf("%d,%d,%d,%d,%d\n",S.value_1,*(S.value_2), 
		    	S.value_3[0],S.value_3[1],S.value_3[2]);
		}
		int main()
		{
		    S1.value_1=43;
		    S1.value_2=(int*)malloc(sizeof(int));
		    *(S1.value_2)=55;
		    S1.value_3[0]=101;
		    S1.value_3[1]=102;
		    S1.value_3[2]=103;
		    printf("S1:");
		    print(S1);
		    S2=S1;
		    printf("S2:");
		    print(S2);
		    S1.value_1=4300;
		    *(S1.value_2)=5500;
		    S1.value_3[0]=10100;
		    S1.value_3[1]=10200;
		    S1.value_3[2]=10300;
		    printf("\nAfter Altering\n");
		    printf("S1:");
		    print(S1);
		    printf("S2:");
		    print(S2);
		    return 0;
		}

