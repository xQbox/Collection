Вопрос  (Общая теория) встречается в 2 3, 25-29
	

Теория:
	Программа на си может получать память из 3 мест:
			1) Сегменты данных (располагаются глобальные переменные)
			
			2) Стек            (автоматическая память)
			
			3) Куча		   (Пул свободной памяти)
				- Дональд Кнут впервые употребил этот термин, 
				  в противовес стека.
				- Нет строгой дисциплины обслуживания ( Берем 
				  первый подходящий объект )
				- Не путать со структурой данных
				- Создать переменную в куче нельзя, но можно
				  выделить память под нее.
				- Преимущества \ недостатки
					+ Можно выделить память бОльшего размера
					  в отличии от автоматической памяти
					+ Размер области памяти не должен быть
					  известен на этапе компиляции
					+ Самостоятельное управление
					  "временем жизни" (выделение\освобождение) 
					
					- Самостоятельное управление 
					  "временем жизни" (выделение\освобождение)
					  
	Каждое приложение на си помещается в абстрактное адресное пространство в которое другое приложение запрыгнуть не может.
			
Дополнительно:
	Свойства области, выделенной malloc(size_t size):
		
		- malloc выделяет по крайней мере указанное количество байт
		  (меньше нельзя, больше можно)
		
		- Указатель, возвращенный malloc, указывает на выделенную 
		  область (т.е область, в которую программа может писать и 
		  из которой может читать данные.
		
		- Ни один другой вызов malloc не может выделить эту область 
		  или ее часть, если только она не была освобождена с помощью  
		  free 
		- Так как возникает вопрос о том, как и где хранить дескрипторы -
					 информацию об области памяти: 
						1) Состояние (занята\свободна) 
						2) Расположение области (адрес)
						3) Размер области
		- Чаще всего для хранения этой информации используют список 
		   из-за ряда преимуществ.
	
	Алгоритм работы функции malloc(size_t size):
		
		- Просмотреть список занятых\свободных областей памяти в поисках 
		  свободной области подходящего размера.
		- Если область имеет точно такой размер, который запрашивает 
		  пользователь, то стоит пометить область как занятую и вернуть
		  указатель на эту область памяти.
		- Если область имеет размер бОльший, чем запросил пользователь.
			1) Разделить эту область на две части
				- Вернуть указатель на область нужного размера
				  пользователю (пункт выше)
				- Добавить блок в кучу свободных областей.
		- Если область не задана, то вернуть NULL
		
	Алгоритм работы функции free(void *ptr):
	
	
	Недостатки (недоделки)
		- Фрагментация
			(Часть занято, часть свободно (1000 байт размер кучи, занято 
				600, запрашивается 400, но из-за дефрагментации 
				выделить одной областью нельзя)
		- Выравнивание
			Для хранения блок памяти должен быть правильно выравнен.В 
			каждой системе есть наиболее требовательный тип данных, если
			элемент этого типа поместиться в указанный блок, то мЕньшие 
			типы также поместятся туда.(Керниган, Ритчи)
		
			1) Решение проблемы выравнивания
			    typedef long long align_t;
			    union block_t
			    {
				struct
				{
					size_t size;
					int free;
					union block_t *next;
				} block;
				
				align_t x;
			    };		
			    block_quantity = 
			    (size + 
			    	sizeof(union block_t n - 1) / sizeof(union block_t n) 
			    				+ 1)
			    alloc_size = block_quantity * 
			    			sizeof(sizeof(union block_t n))   
					
		- Возможность увеличить область, выделенную под кучу.
			(API, от менеджера памяти к операционной системе с запросом 
			увеличения кучи)
	
	
Практика: 
	Пример дескриптора блока памяти	
	struct block_t
	{
		size_t size;
		int free;
		block_t *next;
	};
	
	typedef struct block_t block_t;
	
	#define HEAP_SIZE 1000000
	
	// пространство на кучу
	static char my_heap[HEAP_SIZE];
	
	// список свободных \ занятых областей
	static block_t *free_list = (block_t *) my_heap;
	
	// Начальная инициализация списка свободных \ занятых областей
	static void initialize(void)
	{
		free_list->size = sizeof(my_heap) -  sizeof(block_t);
		free_list->free = 1;
		free_list->next = NULL;
	}
	
	
	
	Реализация malloc
	
	
	void* my_malloc(size_t size)
	{
	    block_t *cur;
	    void *result;

	    if (!free_list->size)
		initialize();
	    
	    cur = free_list;
	    while (cur && (cur->free == 0 ||
		               cur->size < size))
		cur = cur->next;

	    if (!cur)
	    {
		result = NULL;
	        printf("Out of memory\n");
	    } 
	    else if (cur->size == size)
	    {
		cur->free = 0;
		result = (void*) (++cur);
	    }
	    else
	    {
		split_block(cur, size);
		result = (void *)(++cur);
	    }
		
	    return result;
	}
	
	static void split_block(struct block_t *block, size_t size)
	{
	    size_t rest = block->size - size;
	    
	    if (rest > sizeof(struct block_t))
	    {
		struct block_t *new = (void*)((char*)block + size + 
								sizeof(block_t));
		new->size = block->size - size - sizeof(struct block_t);
		new->free = 1;
		new->next = block->next;
	    
		block->size = size;
		block->free = 0;
		block->next = new;
	    }
	    else
		block->free = 0;	
	}
	
	Алгоритм работы free 
		- void my_free(void *ptr)
	  	{
		  	if (my_heap <= (char *) ptr && (char *) ptr < my_heap 
		  						+ sizeof(my_heap)
		  	{
		  		block_t *cur = ptr;
		  		--cur;
		  		cur->free = 1;
		  		merge_blocks();
		  	}
		  	else 
		  	{
		  		printf("Wrong pointer\n");
		  	}
		  }
		- merge_blocks()
		{
			block_t *block->size = block->size + sizeof(*block) + 
						block->next->size;
			block->next = block->next->next;
		}
		
		static void merge_blocks(void)
		{
			block_t *cur = free_list;
			while (cur && cur->next != NULL)
			{
				if (cur->free && cur->next->free)
				{
					cur->size += cur->next->size + sizeof(block_t);
					cur->next = cur->next->next;
				}
				else
					cur = cur->next;
			}
		}			
		

	



	
