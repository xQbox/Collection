Вопрос 5-7 (Make)
Теория:
	-Определение
		1) Утилита make автоматизирует процесс преобразования 				
		файлов из одной формы в другую
		
	-Принцип работы
		Необходимо создать Make-файл (сценарий сборки).
		Этот файл описывает
			1) Отношение между файлами программы.
			2) Содержит команды обновлениия каждого файла.
		Утилита make использует информацию из сценария 
		сборки = (make-файл) и время последнего изменения файла, 
		чтобы решить какие файлы нужно обновлять. 
	-Сценарий сборки:
		цель: зависимость 
		[tab]команда_1
		[tab]команда_2
		упрощенная схема:
			(что создать: из чего создать
				[tab]как сделать.)
	-Запуск
		1) Стандартной целью считается первая цель в make-
		файле.
		
		2) Для сборки определенной цели в командной строке 					
		указывается (make + название цели)
		
		3) Ненулевой код возврата может прервать выполнение
		сценария
		
		4) Каждая команда выполняется в своем shell
	
	-Переменные
		# - комментарий
		
		NAME	:= name (описание переменных. Имя 
		переменной заглавными 
			буквами)
		$(NAME) - обращение к переменной.
		
		.PHONY: - ключевое слово, чтобы make-файл не 
			интерпретировал название цели как имя файл.
			(.PHONY: clean)
		 
	-Неявные правила компиляции файла
		ключ -p для отображения стандартных правил, которые 
		будут применяться неявно.
		 	-CC - стандратная переменная, 
				которая равна cc 
		ключ -r запрещает использование стандартных правил.
	
	-Автоматические переменные 
		"$^" означает "список зависимостей"
		"$@" означает "имя цели" 
		"$<" означает "первую зависимость"
	
	-Шаблонные правила
		%.расширение_файлов_цели: %.расширение_файлов_цели
		(%.o: %.c *.h все си файлы зависят от всех заголовочных 
			файлов)
				  		
	-Условные конструкции
		Для проверки сборки (если mode == debug, то добавляем 
			ключи)
			
		ifeq($(mode),debug)
			CFLAGS += -g3
		endif
		
		(если mode == release, то убираем ненужные ключи)	
		ifeq($(mode), release)
			CFLAGS += -DNDEBUG -g0
		endif
		Значение переменной (mode задается в командной строке
			при вызове make-файла)
			make mode=debug || make mode=release
			
		debug 	: CFLAGS += -g3
		debug 	: цель
		release	: CFLAGS += -g0
		release : цель
		
 	-Анализ зависимостей
 		Компилятор анализирует зависимости
			ключ -M позволяет проверить зависимости (gcc -
			M)
			ключ -MM 
		Как вариант, например, 
		%.d : %.c
		$(SRCS:%.c=%.d) - заменяет в переменной SRCS имена файлов 
		с расширением "с" на иммена с расширением "d"
		include $(SRCS:.c=.d)
		
Дополнительно:
	ключ для проверки времени изменения файла в linux ubuntu 
		ls -la
		
	ключ -f позволяет запустить определенный makefile. Т.е
		если в каталоге лежат несколько makefile, то ключ -f  
		позволяет запустить определенный makefile (makefile1, 
		makefile2).
		
	ключ -B принудительно пересобирает все зависимости.
	
	ключ -n позволяет посмотреть все зависимости сценария сборки.
	
	ключ -i позволяет проигнорировать ошибки компиляции. Т.е.
		собрать все файлы, которые возможно.
	Если есть две одинаковые цели, то на этапе сборке утилита мake
		не соберется 

Практика: 
	-Сценарий сборки
	


Теория:
