Вопрос 7-13 (Динамические матрицы)

Теория:
	- Матрица как одномерный массив
		Преимущества\Недостатки
			+ Память выделяется целым блоком.
			+ Память освобождается одним free.
			+ Возможность использовать как одномерный массив
			
			- Отладчик (valgrind) не может отследить выход 
			за пределы строки.
			- Неудобное обращение к элементу. Т.е
				- i * column + j
	
	- Матрица как массив указателей раздельно
		Преимущества\Недостатки
			+ Возможность обмена строки через обмен 
			указателей
			+ Отладчик использования памяти может отследить
			выход за пределы строки.
			
			- Сложность выделение (требуется больше 1 
			calloc'a)
			- Память под матрицу лежит в разных областях 
			памяти
	
	- Матрица как массив указателей вместе (первый способ)
		Преимущества\Недостатки
			+ Простота выделения и освобождения памяти
			+ Возможность использовать как одномерный
			  массив
			+ Перестановка строк через обмен указателей
				Возможны ошибки :
					- Нужно хранить адрес первой 
					строки 
			
			- Сложность первоначальной инициализации
			- Отладчик не может отследить выход за пределы 
			  строки
	
	- Матрица как массив указателей вместе (второй способ)
		Преимущества\Недостатки
			+ Простота выделения 
			+ Простота освобождения
			+ Возможность использовать как одномерный 
			массив
			+ Перестановка стрко через обмен указателей.
			
			- Сложность начальной инициализации.
			- Отладчик не может отследить выход за пределы 
			строки
			
Дополнительно:
	- Статическая матрица представляется как указатель на массив
		((int *)). Может быть особенным ( если функция 
		запрашивает определенный размер) Т.е foo( int[][4] )
						требует статический 
						массив размера A x 4 
	- Динамическая матрица как одномерный массив представляется
		как указатель на массив 
		(int *)
	- Динамическая матрица как массив указателей представляется
		как массив указателей
		(int **)
				
Практика: 
	- Матрица как одномерный массив
	{
		double *data;
		int n = 3, m = 2;
		data = malloc(sizeof(double) * n * m);
		// инициализация
		for (size_t i = 0; i < n; ++i)
		{
			for (size_t k = 0; k < m; ++k)
			{
				data[i * m + k] = 0.0;
			}
		} 
	}
	
	- Матрица как массив указателей раздельно
	void free_matrix(double **matrix, size_t i)
	{
		for (size_t m = 0; m < i; ++m)
		{
			free(matrix[m]);
		} 
		free(matrix);
	}
	double *matrix_create()
	{
		double **matrix;
		int n = 3, m = 2;
		matrix = calloc(n, sizeof(double *));
		for (size_t i = 0; i < n; ++i)
		{
			matrix[i] = malloc(sizeof(double) * m);
			if (!matrix)
			{
				free_matrix(matrix, i);
				return NULL;
			}
		}
		
		return matrix;	
	}
		
	-Матрица как массив указателй вместе(первый способ)
	
	double **matrix()
	{
		int n = 3, int m = 2;
		double **matrix = malloc(sizeof(double *) * n);
		double *st = malloc(sizeof(double) * n * m);
		for (size_t i = 0; i < n; ++i)	
		{
			matrix[i] = st + i * m; 
		}
		return matrix;
	}
	
	
	- Матрица как массив указателей вместе (второй способ)
	void free_matrix(double **matrix)
	{
		free(matrix)
	}
	double **matrix()
	{
		double **matrix = NULL;
		int n = 3, int m = 2;
		matrix = malloc(sizeof(double *) * n 
		+ n * m * sizeof(double));
		if (!matrix)
			return NULL;
		double *start = (double *) (char *)matrix + n * 
						sizeof(double *);
		for (size_t i = 0; i < n; ++i)
		{
			matrix[i] = start + i * m * 
			sizeof(double); // можно без умножения на 
						sizeof(double) 	
		}
		return matrix;
	}
	
