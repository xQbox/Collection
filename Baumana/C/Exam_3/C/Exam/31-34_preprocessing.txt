Вопрос 31-34 ( Директивы препроцессора )
	- Первая утилита (препроцссор) на пути превращения в исполняемый файл.
	  выполняет удаление комментариев, текстовые замены, включения файлов.
	
	- Работа препроцессора управляется директивами препроцессора.


Теория:	
	- Директивы пропроцессора:
		- Макроопределения (макросы)	1) define 	2) undef 
			- Общие свойства макросов:
				- Препроцессор заменяет только целые лексемы, не их части  
				- Список замены макроса может содержать другие макросы	
				- Определение макроса известно до конца файла (время жизни), в котором он обьявлен.
				- директива #undef позволяет разопределить макрос
				- Макрос не может быть определен дважды, если эти обьявления не равны. 
			Преимущества vs функции
			+ Программа работает быстрее.
			+ Макросы универсальны. (пример с целыми числами и вещественными)
			- скомилированный код становится больше;
			- типы аргументов не проверяются.
			- нельзя объявить указатель на макрос.
			- макрос может вычислять аргументы несколько раз.
				n = MAX(i++, j);
				n = MAX(i, MAX(i+1, j));
			
			- Скобки в макросах (важно помнить приоритет операций)
				- Если список-замены содержит операции, он должен быть
				  заключен в скобки.
				  (#define TWO_PI 2 * 3.14
				  f = 360 / TWO_PI
				  f = 360 / 2 * 3.14 // ERROR
			
				- Если у макроса есть параметры, они должны быть заключены
				  в скобки.
				  #define SCALE(x) (x * 10)
				  j = SCALE(i + 1);
				  j = (i + 1 * 10) // ERROR
				  
				  
			1) Простые макросы
				 #define M 1000
				 #define MEM_ERR "NOT ENOUGH MEMORY"
				 #define EOS '\0'
				 Используются 
				 - для имен числовых, строковых констант
				 - для изменения синтаксиса языка 
					#define BEGIN {
					#define END   }
				 - управления условной компиляцией

				 - переименования типов
				 	#define BOOL int (до С99 не было bool) 
				 	для таких решений лучше использовать typedef,
				 	так как у компилятора больше возможностей
				 	проверить корректность работы программы.
				 	
				 		 	
			2) Макросы с параметрами 
			(индентификатор(х, х1, х2 - список параметров) список замены)
				- Между индентификатором и списком параметров
						не должно быть пробела.
				- Список параметров может быть пустым.  
				
				
				#define MAX(x, y) ((x) > (y)) : (x) ? (y))
				#define IS_EVEN(x) ((x) % 2 == 0)
			
			
			3) Макросы с переменным числом параметров C99
				 Пример для отладочной печати
				 #ifndef NDEGUB
				 #define DBG_PRINT(s, ...) printf(s, __VA_ARGS__)
				 #else
				 #define DBG_PRINT(s, ...) ((void) 0) 
				 #endif
		
		
			4) Длинные макросы
			  Неправильно
			  #define ECHO(s) {gets(s); puts(s);}
			  
			  if (echo_flag)
			  	ECHO(str);
			  else 
			  	gets(str);
			  Правильно 
			  #define ECHO(s)	(gets(s), puts(s))
			  
			  ECHO(str);	
			  Правильно 
			  #define ECHO(s) \
			  do	          \
			  {               \
			  	gets(s);  \
			  	puts(s);  \
			  }               \
			  while(0)	  \
			
			
			5) Предопределенные макросы (нельзя undef)
				__LINE__	номер текущей строки
				__FILE__	имя компилируемого файла
				__DATE__	дата компиляции
				__TIME__   	время компиляции
				__func__ 	имя функции как строка (GCC only, C99 не макрос)
				
					
		- Включения файлов
			1) include
		
		
		
		
		- Директивы условной компиляции (для защиты заголовочных файлов
		  от повторного включения) 1) ifndef 2) endif 3) if
			- Условная компиляции ( способы применения )
				- программа должна компилироваться разными компиляторами.
				- программа реализуется на разных Операционных системах.
				- для ввода начального значения макросов.
				- для временного выключения кода.
				  
	  		- ifndef (ifdef)
		  		
		  		
		  		
	  		- if		
	
	
	
		- Остальные директивы 
			1) #error
				- выводит переданное сообщение и прерывает компиляцию
				- для проверки достижения условных конструкции
				
			2) #pragma
				- позволяет добиться от компилятора специфичного поведения		
			
	- Общие свойства директив
		- любая директива начинается с #
		- любое количество пробельных символов может разделять лексемы в
									директиве
		- любая директива заканчивается на символе \n
				Пример 
					1) #   define    N         1000 
					2) #   define DISK_CAPACITY	(SIDES * \
									 RAM	* \
									 BYTES	* \
									 HASH_TYPE *\
									 SIZE )
					2. Пояснение: с помощь \ можно переносить в
						директиву на другую строчку.
						  
		- могут появляться в любом месте программе
		
		
	Операции препроцессора:
		1)  # - конвертирует аргумента макроса в строковый литерал.
		2) ## - склеивает две лексемы в одну.
			(#define GENERAL_MAX(type)
				type type##_max(type x, type y)	\
				{				\
					return x > y ? x : y; 	\ 
				}
		
		
Дополнительно:
	- Ключ NDEBUG - удаляет утверждения.
	(передается в качестве ключа для компиляции программы).
	
	- E для выдачи результата работы препроцессора. ((void) 0)
	
	- Аргументы подставляются в список замены уже раскрытыми, если к ним не применяются 
		операции # или ##
	
	- После того, как все аргумменты были раскрыты или выполнены операции # или ##, результат 
	  просматривается препроцессором еще раз. Если результат работы препроцессора содержит имя 
	  исходного макроса, то оно не заменяется.
			- Для решения проблемы нераскрытия макросов вводят дополнительные параметры
			  #define STR_HELPER(x) #x
			  #define STR(x) STR_HELPER(x)
			  #define NAME bob
			  int main(void)
			  {
			   	puts(STR(10));
			   	
			   	puts(STR(NAME));

			   	return 0;
			  }
		
		
	-cpp main.c > main.i (результат работы препроцессора)
	-gcc -S main.i (перевод файла в ассемблерный код)		   
	
Практика: 
	
