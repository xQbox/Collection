/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "basic.check" instead.
 */

#include <check.h>

#include "libmy.h"
#include <string.h>
#define ARR_SIZE 10

START_TEST(key_1_pos)
{
/// Позитивный тест 1 для функции key (все цифры положительные)
int IDOL [ARR_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *ptrs = malloc(ARR_SIZE * sizeof(int)); 
int *ptrend = ptrs + ARR_SIZE;
int rc = ERR_OK;
rc = key(IDOL, IDOL + ARR_SIZE, &ptrs, &ptrend);
for (size_t i = 0; i < ARR_SIZE; i++)
{
    if ((*(IDOL + i)) != (*(ptrs + i)))
        rc = ERR_SIZE;
}
int rc_fin = ERR_OK;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(key_2_pos)
{
/// Позитивный тест 2 для функции key (8-ая цифра отрицательная)
int IDOL [ARR_SIZE] = {1, 2, 3, 4, 5, 6, 7, -8, 9, 10};
size_t size = ARR_SIZE - 3;
int *ptrs = malloc((size) * sizeof(int)); 
int *ptrend = ptrs + size;
int rc = ERR_OK;
rc = key(IDOL, IDOL + size, &ptrs, &ptrend);
for (size_t i = 0; i < size; i++)
{
    if ((*(IDOL + i)) != (*(ptrs + i)))
        rc = ERR_SIZE;
}
int rc_fin = ERR_OK;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(key_3_pos)
{
/// Позитивный тест 3 для функции key (4-ая цифра отрицательная)
int IDOL [ARR_SIZE] = {1, 2, 3, -4, 5, 6, 7, 8, 9, 10};
size_t size = ARR_SIZE - 7;
int *ptrs = malloc((size) * sizeof(int)); 
int *ptrend = ptrs + size;
int rc = ERR_OK;
rc = key(IDOL, IDOL + size, &ptrs, &ptrend);
for (size_t i = 0; i < size; i++)
{
    if ((*(IDOL + i)) != (*(ptrs + i)))
        rc = ERR_SIZE;
}
int rc_fin = ERR_OK;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);


///----------------------------------------------------------


}
END_TEST

START_TEST(key_1_neg)
{
/// Отрицательный тест 1 для функции key (0 размер массива)
int IDOL [ARR_SIZE] = {-1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
size_t size = ARR_SIZE - 7;
int *ptrs = malloc((size) * sizeof(int)); 
int *ptrend = ptrs + size;
int rc = ERR_OK;
rc = key(IDOL, IDOL + size, &ptrs, &ptrend);
int rc_fin = ERR_ARR_SIZE;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);



}
END_TEST

START_TEST(key_2_neg)
{
/// Отрицательный тест 2 для функции key (1-ый указатель пустой)
int IDOL [ARR_SIZE] = {1, 2, 3, -4, 5, 6, 7, 8, 9, 10};
size_t size = ARR_SIZE - 7;
int *ptrs = malloc((size) * sizeof(int)); 
int *ptrend = ptrs + size;
int rc = ERR_OK;
rc = key(NULL, IDOL + size, &ptrs, &ptrend);
int rc_fin = ERR_SIZE;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(key_3_neg)
{
/// Отрицательный тест 3 для функции key (2- ой указатель пустой)
int IDOL [ARR_SIZE] = {1, 2, 3, -4, 5, 6, 7, 8, 9, 10};
size_t size = ARR_SIZE - 7;
int *ptrs = malloc(size * sizeof(int)); 
int *ptrend = ptrs + size;
int rc = ERR_OK;
rc = key(IDOL, NULL, &ptrs, &ptrend);
int rc_fin = ERR_SIZE;
free(ptrs);
ck_assert_int_eq(rc, rc_fin);

///----------------------------------------------------------

}
END_TEST

START_TEST(buble_sort_main_1)
{
/// Тест для функции сортировки (1 число)
size_t size = 1;
int IDOL[ARR_SIZE-9] = {1};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = 0; ps < ptrs + size; ps++, i++)
    *ps = (i + 1);
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);

}
END_TEST

START_TEST(buble_sort_main_2)
{
/// Тест для функции сортировки (2 элементов ->)
const size_t size = 2;
int IDOL[ARR_SIZE - 8] = {1, 2};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = 0; ps < ptrs + size; ps++, i++)
    *ps = (i + 1);
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);


}
END_TEST

START_TEST(buble_sort_main_3)
{
/// Тест для функции сортировки (2 элементов <-)
const size_t size = 2;
int IDOL[ARR_SIZE - 8] = {1, 2};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = size; ps < ptrs + size; ps++, i--)
    *ps = i;
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);


}
END_TEST

START_TEST(buble_sort_main_4)
{
/// Тест для функции сортировки (10 элементов ->)
const size_t size = 10;
int IDOL[ARR_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = 0; ps < ptrs + size; ps++, i++)
    *ps = (i + 1);
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);


}
END_TEST

START_TEST(buble_sort_main_5)
{
/// Тест для функции сортировки (10 элементов <-)
const size_t size = 10;
int IDOL[ARR_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = size; ps < ptrs + size; ps++, i--)
    *ps = i;
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);


}
END_TEST

START_TEST(buble_sort_main_6)
{
/// Тест для функции сортировки (10 элементов случайных с повторения)
const size_t size = 10;
int IDOL[ARR_SIZE] = {1, 2, 3, 5, 5, 6, 6, 8, 9, 10};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = size - 1; ps < ptrs + size; ps++, i--)
    if ((i+1) == 4)
        *ps = 5;
    else if ((i + 1) == 7)
        *ps = 6;
    else if ((i + 1) == 3)
        *ps = 9; 
    else if ((i + 1) == 9)
        *ps = 3;
    else
        *ps = i + 1;
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);

}
END_TEST

START_TEST(buble_sort_main_7)
{
/// Тест для функции сортировки (10 элементов случайная)
const size_t size = 10;
int IDOL[ARR_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *ptrs = malloc(size * sizeof(int));
int *ps = ptrs;
int rc = ERR_OK;
for(int i = size - 1; ps < ptrs + size; ps++, i--)
    if ((i + 1) == 7)
        *ps = 5;
    else if ((i + 1) == 5)
        *ps = 7;
    else if ((i + 1) == 3)
        *ps = 9; 
    else if ((i + 1) == 9)
        *ps = 3;
    else
        *ps = i + 1;
mysort(ptrs, size, sizeof(int), comp);
for (size_t i = 0; i < size; i++)
{
    if (IDOL[i] != *(ptrs + i))
        rc = ERR_SIZE;
}
free(ptrs);
int rc_fin = ERR_OK;
ck_assert_int_eq(rc , rc_fin);



}
END_TEST
///----------------------------------------------------------

START_TEST(comp_1)
{
/// Тест для функции сравнения двух элементов (сравнение int)
int A[2] = {10000 , 2200000};
int rc = ERR_OK;
if (comp(A, A + 1) < 0)
    rc = ERR_OK;
else 
    rc = 1;
ck_assert_int_eq(rc, ERR_OK);


}
END_TEST

START_TEST(comp_2)
{
/// Тест для функции сравнения двух элементов (сравнение int)
char b = 'b';
char a = 'a';
int rc = ERR_OK;
if (comp(&a, &b) < 0)
    rc = ERR_OK;
else 
    rc = 1;
ck_assert_int_eq(rc, ERR_OK);


}
END_TEST

START_TEST(comp_3)
{
/// Тест для функции сравнения двух элементов (сравнение int)
int b = 10000;
int a = 999;
int rc = ERR_OK;
if (comp(&a, &b) < 0)
    rc = ERR_OK;
else 
    rc = 1;

ck_assert_int_eq(rc, ERR_OK);

///----------------------------------------------------------

}
END_TEST

START_TEST(swap_1)
{
/// Тест для функции обмена элементов переменных между собой (int , int)
int b = 10000;
int a = 9999;
int rc = ERR_OK;
swap(&a, &b, sizeof(int));
if (a == 10000 && b == 9999)
    rc = ERR_OK;
else    
    rc = ERR_SIZE;

ck_assert_int_eq(rc, ERR_OK);

}
END_TEST

START_TEST(swap_2)
{
/// Тест для функции обмена элементов переменных между собой (char , char)
char b = 'b';
char a = 'a';;
int rc = ERR_OK;
swap(&a, &b, sizeof(char));
if (a == 'b' && b == 'a')
    rc = ERR_OK;
else    
    rc = ERR_SIZE;

ck_assert_int_eq(rc, ERR_OK);


}
END_TEST

START_TEST(swap_3)
{
/// Тест для функции обмена элементов переменных между собой (strcut , struct)
struct book_t
{
    int public_data;
    char name[29];
};
struct book_t book2, book1;
book1.public_data = 1971;
strcpy(book1.name, "Айзек Азимов");
book2.public_data = 2023;
strcpy(book2.name, "Алексей Пехов");
int rc = ERR_OK;
swap(&book1, &book2, sizeof(book1));
if (((strcmp(book1.name, "Алексей Пехов")) == 0) && (book1.public_data == 2023))
{
    if (((strcmp(book2.name, "Айзек Азимов")) == 0) && (book2.public_data == 1971))
        rc = ERR_OK;
    else 
        rc = ERR_SIZE;
}
else 
    rc = ERR_SIZE;
ck_assert_int_eq(rc, ERR_OK);
#include <stdio.h>
#include <stdlib.h>
#define ARR_SIZE 10
#include "libmy.h"

}
END_TEST

START_TEST(check_file_1_pos)
{
/// Positive test 1 (low high)

char *filename = "INFILE0.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
if (size != 10)
    rc = ERR_DATA_FILE;
int rc_fin = ERR_OK;
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(check_file_2_pos)
{
/// Positive test 2 (normal order)

char *filename = "INFILE1.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
if (size != 10)
    rc = ERR_DATA_FILE;
int rc_fin = ERR_OK;
ck_assert_int_eq(rc, rc_fin);


}
END_TEST

START_TEST(check_file_3_pos)
{
/// Positive test 3 (only one digit)

char *filename = "INFILE2.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
if (size != 1)
    rc = ERR_DATA_FILE;
int rc_fin = ERR_OK;
ck_assert_int_eq(rc, rc_fin);


}
END_TEST

START_TEST(check_file_4_pos)
{
/// Positive test 4 (extreme digit)

char *filename = "INFILE3.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
if (size != 10)
    rc = ERR_DATA_FILE;
int rc_fin = ERR_OK;
ck_assert_int_eq(rc, rc_fin);

///------------------------------------------------

}
END_TEST

START_TEST(check_file_1_neg)
{
/// Negative test 1 (file not exist)

char *filename = "INFILE0_NEG.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
int rc_fin = ERR_FILE_OPEN;
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(check_file_2_neg)
{
/// Negative test 2 (symbols in file)

char *filename = "INFILE1_NEG.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
if (size != 10)
    rc = ERR_DATA_FILE;
int rc_fin = ERR_DATA_FILE;
ck_assert_int_eq(rc, rc_fin);


}
END_TEST

START_TEST(check_file_3_neg)
{
/// Negative test 3 (empty file)
size_t size = 0;
char *filename = "INFILE2_NEG.txt";
int rc = ERR_OK;
rc = file_check(filename, &size);
int rc_fin = ERR_EMPTY_FILE;
ck_assert_int_eq(rc, rc_fin);


}
END_TEST

START_TEST(check_file_4_neg)
{
/// Negative test 4 (symbols between digits)

char *filename = "INFILE3_NEG.txt";
size_t size = 0;
int rc = ERR_OK;
rc = file_check(filename, &size);
int rc_fin = ERR_EMPTY_FILE;
ck_assert_int_eq(rc, rc_fin);

///------------------------------------------------

}
END_TEST

START_TEST(arr_create_1_pos)
{
/// Positive test 1 (order with negative numbers)

char *filename = "ARR_CREATE.txt";
int A[ARR_SIZE];
int B[ARR_SIZE] = {0, 9 , 8, 7, 6, 5, 4, -3, 2, 1};
int rc;
rc = arr_create(filename, A);

for(size_t i = 0 ; i < ARR_SIZE; i++)
{
    if (A[i] != B[i])
        rc = ERR_FILE_IO;
}
int rc_fin = ERR_OK;
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(arr_create_1_neg)
{
/// Negative test 1 (symbols in file)

char *filename = "ARR_CREATE_NEG.txt";
int A[ARR_SIZE];
int B[ARR_SIZE] = {0, 9 , 0 , 9, 0 , 0 , 0, 9 ,9 , 10};
int rc;
rc = arr_create(filename, A);

for(size_t i = 0 ; i < ARR_SIZE; i++)
{
    if (A[i] != B[i])
        rc = ERR_FILE_IO;
}
int rc_fin = ERR_FILE_IO;
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

START_TEST(arr_create_2_neg)
{
/// Negative test 2 (file not exist)

char *filename = "1";
int rc = ERR_OK;
int A[ARR_SIZE];
rc = arr_create(filename, A);
int rc_fin = ERR_FILE_OPEN;
ck_assert_int_eq(rc, rc_fin);

}
END_TEST

int main(void)
{
    Suite *s1 = suite_create("Core");
    TCase *tc1_1 = tcase_create("Core");
    SRunner *sr = srunner_create(s1);
    int nf;

    suite_add_tcase(s1, tc1_1);
    tcase_add_test(tc1_1, key_1_pos);
    tcase_add_test(tc1_1, key_2_pos);
    tcase_add_test(tc1_1, key_3_pos);
    tcase_add_test(tc1_1, key_1_neg);
    tcase_add_test(tc1_1, key_2_neg);
    tcase_add_test(tc1_1, key_3_neg);
    tcase_add_test(tc1_1, buble_sort_main_1);
    tcase_add_test(tc1_1, buble_sort_main_2);
    tcase_add_test(tc1_1, buble_sort_main_3);
    tcase_add_test(tc1_1, buble_sort_main_4);
    tcase_add_test(tc1_1, buble_sort_main_5);
    tcase_add_test(tc1_1, buble_sort_main_6);
    tcase_add_test(tc1_1, buble_sort_main_7);
    tcase_add_test(tc1_1, comp_1);
    tcase_add_test(tc1_1, comp_2);
    tcase_add_test(tc1_1, comp_3);
    tcase_add_test(tc1_1, swap_1);
    tcase_add_test(tc1_1, swap_2);
    tcase_add_test(tc1_1, swap_3);
    tcase_add_test(tc1_1, check_file_1_pos);
    tcase_add_test(tc1_1, check_file_2_pos);
    tcase_add_test(tc1_1, check_file_3_pos);
    tcase_add_test(tc1_1, check_file_4_pos);
    tcase_add_test(tc1_1, check_file_1_neg);
    tcase_add_test(tc1_1, check_file_2_neg);
    tcase_add_test(tc1_1, check_file_3_neg);
    tcase_add_test(tc1_1, check_file_4_neg);
    tcase_add_test(tc1_1, arr_create_1_pos);
    tcase_add_test(tc1_1, arr_create_1_neg);
    tcase_add_test(tc1_1, arr_create_2_neg);

    srunner_run_all(sr, CK_ENV);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);

    return nf == 0 ? 0 : 1;
}
